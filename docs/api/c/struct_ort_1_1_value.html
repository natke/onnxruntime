<!-- HTML header for doxygen -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OnnxRuntime: Ort::Value Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-156955408-1"></script><script type="text/javascript">"use strict"; window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-156955408-1'); </script> <script type="text/javascript" src="/assets/js/vendor/lunr.min.js"></script> <script type="text/javascript" src="/assets/js/just-the-docs.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ONNX_Runtime_logo - Docs.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OnnxRuntime
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('struct_ort_1_1_value.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="struct_ort_1_1_value-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Ort::Value Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Wrapper around <a class="el" href="group___global.html#gaab167acf3fe9dabc0195b993fbe7ee7d">OrtValue</a>.  
 <a href="struct_ort_1_1_value.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="onnxruntime__cxx__api_8h_source.html">onnxruntime_cxx_api.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Ort::Value:</div>
<div class="dyncontent">
 <div class="center">
  <img src="struct_ort_1_1_value.png" usemap="#Ort::Value_map" alt=""/>
  <map id="Ort::Value_map" name="Ort::Value_map">
<area href="struct_ort_1_1detail_1_1_value_impl.html" alt="Ort::detail::ValueImpl&lt; OrtValue &gt;" shape="rect" coords="0,112,234,136"/>
<area href="struct_ort_1_1detail_1_1_const_value_impl.html" alt="Ort::detail::ConstValueImpl&lt; T &gt;" shape="rect" coords="0,56,234,80"/>
<area href="struct_ort_1_1detail_1_1_base.html" title="Used internally by the C++ API. C++ wrapper types inherit from this. This is a zero cost abstraction ..." alt="Ort::detail::Base&lt; T &gt;" shape="rect" coords="0,0,234,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:acaa37dd471180adc7e0feba8bee065c9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#acaa37dd471180adc7e0feba8bee065c9">Base</a> = <a class="el" href="struct_ort_1_1detail_1_1_value_impl.html">detail::ValueImpl</a>&lt; <a class="el" href="group___global.html#gaab167acf3fe9dabc0195b993fbe7ee7d">OrtValue</a> &gt;</td></tr>
<tr class="separator:acaa37dd471180adc7e0feba8bee065c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a488c55bbedb38c3f505a4fe6accc36bf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#a488c55bbedb38c3f505a4fe6accc36bf">OrtSparseValuesParam</a> = <a class="el" href="struct_ort_1_1detail_1_1_ort_sparse_values_param.html">detail::OrtSparseValuesParam</a></td></tr>
<tr class="separator:a488c55bbedb38c3f505a4fe6accc36bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa887af73b5a841819423295063c10836"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#aa887af73b5a841819423295063c10836">Shape</a> = <a class="el" href="struct_ort_1_1detail_1_1_shape.html">detail::Shape</a></td></tr>
<tr class="separator:aa887af73b5a841819423295063c10836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_struct_ort_1_1detail_1_1_value_impl"><td colspan="2" onclick="javascript:toggleInherit('pub_types_struct_ort_1_1detail_1_1_value_impl')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="struct_ort_1_1detail_1_1_value_impl.html">Ort::detail::ValueImpl&lt; OrtValue &gt;</a></td></tr>
<tr class="memitem:aa56bd5e28c57ca24311ce48792326d6e inherit pub_types_struct_ort_1_1detail_1_1_value_impl"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_value_impl.html#aa56bd5e28c57ca24311ce48792326d6e">B</a> = <a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html">ConstValueImpl</a>&lt; <a class="el" href="group___global.html#gaab167acf3fe9dabc0195b993fbe7ee7d">OrtValue</a> &gt;</td></tr>
<tr class="separator:aa56bd5e28c57ca24311ce48792326d6e inherit pub_types_struct_ort_1_1detail_1_1_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80f19abb74be8f5a489ae95eaa13905 inherit pub_types_struct_ort_1_1detail_1_1_value_impl"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_value_impl.html#ab80f19abb74be8f5a489ae95eaa13905">B</a> = <a class="el" href="struct_ort_1_1detail_1_1_base.html">Base</a>&lt; <a class="el" href="group___global.html#gaab167acf3fe9dabc0195b993fbe7ee7d">OrtValue</a> &gt;</td></tr>
<tr class="separator:ab80f19abb74be8f5a489ae95eaa13905 inherit pub_types_struct_ort_1_1detail_1_1_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_struct_ort_1_1detail_1_1_const_value_impl"><td colspan="2" onclick="javascript:toggleInherit('pub_types_struct_ort_1_1detail_1_1_const_value_impl')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html">Ort::detail::ConstValueImpl&lt; T &gt;</a></td></tr>
<tr class="memitem:ab80f19abb74be8f5a489ae95eaa13905 inherit pub_types_struct_ort_1_1detail_1_1_const_value_impl"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#ab80f19abb74be8f5a489ae95eaa13905">B</a> = <a class="el" href="struct_ort_1_1detail_1_1_base.html">Base</a>&lt; T &gt;</td></tr>
<tr class="separator:ab80f19abb74be8f5a489ae95eaa13905 inherit pub_types_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_struct_ort_1_1detail_1_1_base"><td colspan="2" onclick="javascript:toggleInherit('pub_types_struct_ort_1_1detail_1_1_base')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="struct_ort_1_1detail_1_1_base.html">Ort::detail::Base&lt; T &gt;</a></td></tr>
<tr class="memitem:adac6328b9d9b37cddd94f6b21bebee74 inherit pub_types_struct_ort_1_1detail_1_1_base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_base.html#adac6328b9d9b37cddd94f6b21bebee74">contained_type</a> = T</td></tr>
<tr class="separator:adac6328b9d9b37cddd94f6b21bebee74 inherit pub_types_struct_ort_1_1detail_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a233d9a9878a69295ad504ea2b22b4d1f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#a233d9a9878a69295ad504ea2b22b4d1f">Value</a> (std::nullptr_t)</td></tr>
<tr class="memdesc:a233d9a9878a69295ad504ea2b22b4d1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty <a class="el" href="struct_ort_1_1_value.html" title="Wrapper around OrtValue.">Value</a> object, must be assigned a valid one to be used.  <br /></td></tr>
<tr class="separator:a233d9a9878a69295ad504ea2b22b4d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e744a54c1fe6c477cccbe33b580fe3b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#a4e744a54c1fe6c477cccbe33b580fe3b">Value</a> (<a class="el" href="group___global.html#gaab167acf3fe9dabc0195b993fbe7ee7d">OrtValue</a> *p)</td></tr>
<tr class="memdesc:a4e744a54c1fe6c477cccbe33b580fe3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for interop with the C API.  <br /></td></tr>
<tr class="separator:a4e744a54c1fe6c477cccbe33b580fe3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7884f57758a06ca3b1203fcff98a08"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#a1b7884f57758a06ca3b1203fcff98a08">Value</a> (<a class="el" href="struct_ort_1_1_value.html">Value</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a1b7884f57758a06ca3b1203fcff98a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ce9c0a1b41a61eb0f94bc9070539eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ort_1_1_value.html">Value</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#a14ce9c0a1b41a61eb0f94bc9070539eb">operator=</a> (<a class="el" href="struct_ort_1_1_value.html">Value</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a14ce9c0a1b41a61eb0f94bc9070539eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7df58aec9512b5744e9869b0360ee77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ort.html#afe583bdd408314ab9216f27997fe3cfe">ConstValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#ae7df58aec9512b5744e9869b0360ee77">GetConst</a> () const</td></tr>
<tr class="separator:ae7df58aec9512b5744e9869b0360ee77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5def834adf6750b31b7fdead89b67a07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ort.html#ae76d2b32827c348b72fbe4091ee40f92">UnownedValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#a5def834adf6750b31b7fdead89b67a07">GetUnowned</a> () const</td></tr>
<tr class="separator:a5def834adf6750b31b7fdead89b67a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_struct_ort_1_1detail_1_1_value_impl"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_struct_ort_1_1detail_1_1_value_impl')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="struct_ort_1_1detail_1_1_value_impl.html">Ort::detail::ValueImpl&lt; OrtValue &gt;</a></td></tr>
<tr class="memitem:a28317ae875d9c8b35f0cbed64f776c5a inherit pub_methods_struct_ort_1_1detail_1_1_value_impl"><td class="memItemLeft" align="right" valign="top">R *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_value_impl.html#a28317ae875d9c8b35f0cbed64f776c5a">GetTensorMutableData</a> ()</td></tr>
<tr class="memdesc:a28317ae875d9c8b35f0cbed64f776c5a inherit pub_methods_struct_ort_1_1detail_1_1_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a non-const typed pointer to an OrtValue/Tensor contained buffer No type checking is performed, the caller must ensure the type matches the tensor type.  <br /></td></tr>
<tr class="separator:a28317ae875d9c8b35f0cbed64f776c5a inherit pub_methods_struct_ort_1_1detail_1_1_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b55de64b5457b5fd0538ec8225a0507 inherit pub_methods_struct_ort_1_1detail_1_1_value_impl"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_value_impl.html#a8b55de64b5457b5fd0538ec8225a0507">GetTensorMutableRawData</a> ()</td></tr>
<tr class="memdesc:a8b55de64b5457b5fd0538ec8225a0507 inherit pub_methods_struct_ort_1_1detail_1_1_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a non-typed non-const pointer to a tensor contained data.  <br /></td></tr>
<tr class="separator:a8b55de64b5457b5fd0538ec8225a0507 inherit pub_methods_struct_ort_1_1detail_1_1_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657fe9ca6bd6e2dc09c0beb95ee3e1eb inherit pub_methods_struct_ort_1_1detail_1_1_value_impl"><td class="memItemLeft" align="right" valign="top">R &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_value_impl.html#a657fe9ca6bd6e2dc09c0beb95ee3e1eb">At</a> (const std::vector&lt; int64_t &gt; &amp;location)</td></tr>
<tr class="separator:a657fe9ca6bd6e2dc09c0beb95ee3e1eb inherit pub_methods_struct_ort_1_1detail_1_1_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98717a93e02f4b91ebabaf3c4ab891c inherit pub_methods_struct_ort_1_1detail_1_1_value_impl"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_value_impl.html#ac98717a93e02f4b91ebabaf3c4ab891c">FillStringTensor</a> (const char *const *s, size_t s_len)</td></tr>
<tr class="memdesc:ac98717a93e02f4b91ebabaf3c4ab891c inherit pub_methods_struct_ort_1_1detail_1_1_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all strings at once in a string tensor.  <br /></td></tr>
<tr class="separator:ac98717a93e02f4b91ebabaf3c4ab891c inherit pub_methods_struct_ort_1_1detail_1_1_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a59534f82ccf9ff55b8a692270e4503 inherit pub_methods_struct_ort_1_1detail_1_1_value_impl"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_value_impl.html#a0a59534f82ccf9ff55b8a692270e4503">FillStringTensorElement</a> (const char *s, size_t index)</td></tr>
<tr class="memdesc:a0a59534f82ccf9ff55b8a692270e4503 inherit pub_methods_struct_ort_1_1detail_1_1_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a single string in a string tensor.  <br /></td></tr>
<tr class="separator:a0a59534f82ccf9ff55b8a692270e4503 inherit pub_methods_struct_ort_1_1detail_1_1_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b80e2a725f45cdeceb06bcba643e978 inherit pub_methods_struct_ort_1_1detail_1_1_value_impl"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_value_impl.html#a8b80e2a725f45cdeceb06bcba643e978">UseCooIndices</a> (int64_t *indices_data, size_t indices_num)</td></tr>
<tr class="memdesc:a8b80e2a725f45cdeceb06bcba643e978 inherit pub_methods_struct_ort_1_1detail_1_1_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supplies COO format specific indices and marks the contained sparse tensor as being a COO format tensor. Values are supplied with a CreateSparseTensor() API. The supplied indices are not copied and the user allocated buffers lifespan must eclipse that of the OrtValue. The location of the indices is assumed to be the same as specified by OrtMemoryInfo argument at the creation time.  <br /></td></tr>
<tr class="separator:a8b80e2a725f45cdeceb06bcba643e978 inherit pub_methods_struct_ort_1_1detail_1_1_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc53699ae881046ccf26527fb0e0d7d2 inherit pub_methods_struct_ort_1_1detail_1_1_value_impl"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_value_impl.html#adc53699ae881046ccf26527fb0e0d7d2">UseCsrIndices</a> (int64_t *inner_data, size_t inner_num, int64_t *outer_data, size_t outer_num)</td></tr>
<tr class="memdesc:adc53699ae881046ccf26527fb0e0d7d2 inherit pub_methods_struct_ort_1_1detail_1_1_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supplies CSR format specific indices and marks the contained sparse tensor as being a CSR format tensor. Values are supplied with a CreateSparseTensor() API. The supplied indices are not copied and the user allocated buffers lifespan must eclipse that of the OrtValue. The location of the indices is assumed to be the same as specified by OrtMemoryInfo argument at the creation time.  <br /></td></tr>
<tr class="separator:adc53699ae881046ccf26527fb0e0d7d2 inherit pub_methods_struct_ort_1_1detail_1_1_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ba9e6d44e6a1141c04d1fefaa3b6c6 inherit pub_methods_struct_ort_1_1detail_1_1_value_impl"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_value_impl.html#a68ba9e6d44e6a1141c04d1fefaa3b6c6">UseBlockSparseIndices</a> (const <a class="el" href="struct_ort_1_1detail_1_1_shape.html">Shape</a> &amp;indices_shape, int32_t *indices_data)</td></tr>
<tr class="memdesc:a68ba9e6d44e6a1141c04d1fefaa3b6c6 inherit pub_methods_struct_ort_1_1detail_1_1_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supplies BlockSparse format specific indices and marks the contained sparse tensor as being a BlockSparse format tensor. Values are supplied with a CreateSparseTensor() API. The supplied indices are not copied and the user allocated buffers lifespan must eclipse that of the OrtValue. The location of the indices is assumed to be the same as specified by OrtMemoryInfo argument at the creation time.  <br /></td></tr>
<tr class="separator:a68ba9e6d44e6a1141c04d1fefaa3b6c6 inherit pub_methods_struct_ort_1_1detail_1_1_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30c08c17ce26d0c89e8c7dea62f9a75 inherit pub_methods_struct_ort_1_1detail_1_1_value_impl"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_value_impl.html#ab30c08c17ce26d0c89e8c7dea62f9a75">FillSparseTensorCoo</a> (const <a class="el" href="group___global.html#ga088f45e429651ac29b4a9efb4d88571a">OrtMemoryInfo</a> *data_mem_info, const <a class="el" href="struct_ort_1_1detail_1_1_ort_sparse_values_param.html">OrtSparseValuesParam</a> &amp;values_param, const int64_t *indices_data, size_t indices_num)</td></tr>
<tr class="memdesc:ab30c08c17ce26d0c89e8c7dea62f9a75 inherit pub_methods_struct_ort_1_1detail_1_1_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API will allocate memory using the allocator instance supplied to the CreateSparseTensor() API and copy the values and COO indices into it. If data_mem_info specifies that the data is located at difference device than the allocator, a X-device copy will be performed if possible.  <br /></td></tr>
<tr class="separator:ab30c08c17ce26d0c89e8c7dea62f9a75 inherit pub_methods_struct_ort_1_1detail_1_1_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67cc830bdf35e40717b06ca70b22ead inherit pub_methods_struct_ort_1_1detail_1_1_value_impl"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_value_impl.html#af67cc830bdf35e40717b06ca70b22ead">FillSparseTensorCsr</a> (const <a class="el" href="group___global.html#ga088f45e429651ac29b4a9efb4d88571a">OrtMemoryInfo</a> *data_mem_info, const <a class="el" href="struct_ort_1_1detail_1_1_ort_sparse_values_param.html">OrtSparseValuesParam</a> &amp;values, const int64_t *inner_indices_data, size_t inner_indices_num, const int64_t *outer_indices_data, size_t outer_indices_num)</td></tr>
<tr class="memdesc:af67cc830bdf35e40717b06ca70b22ead inherit pub_methods_struct_ort_1_1detail_1_1_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API will allocate memory using the allocator instance supplied to the CreateSparseTensor() API and copy the values and CSR indices into it. If data_mem_info specifies that the data is located at difference device than the allocator, a X-device copy will be performed if possible.  <br /></td></tr>
<tr class="separator:af67cc830bdf35e40717b06ca70b22ead inherit pub_methods_struct_ort_1_1detail_1_1_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a57d606a608abda7df7b9b23a301a3e inherit pub_methods_struct_ort_1_1detail_1_1_value_impl"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_value_impl.html#a7a57d606a608abda7df7b9b23a301a3e">FillSparseTensorBlockSparse</a> (const <a class="el" href="group___global.html#ga088f45e429651ac29b4a9efb4d88571a">OrtMemoryInfo</a> *data_mem_info, const <a class="el" href="struct_ort_1_1detail_1_1_ort_sparse_values_param.html">OrtSparseValuesParam</a> &amp;values, const <a class="el" href="struct_ort_1_1detail_1_1_shape.html">Shape</a> &amp;indices_shape, const int32_t *indices_data)</td></tr>
<tr class="memdesc:a7a57d606a608abda7df7b9b23a301a3e inherit pub_methods_struct_ort_1_1detail_1_1_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API will allocate memory using the allocator instance supplied to the CreateSparseTensor() API and copy the values and BlockSparse indices into it. If data_mem_info specifies that the data is located at difference device than the allocator, a X-device copy will be performed if possible.  <br /></td></tr>
<tr class="separator:a7a57d606a608abda7df7b9b23a301a3e inherit pub_methods_struct_ort_1_1detail_1_1_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_struct_ort_1_1detail_1_1_const_value_impl')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html">Ort::detail::ConstValueImpl&lt; T &gt;</a></td></tr>
<tr class="memitem:ab541b268a2aad607ceec3a3da7be8ba0 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:ab541b268a2aad607ceec3a3da7be8ba0 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#ab541b268a2aad607ceec3a3da7be8ba0">GetOpaqueData</a> (const char *domain, const char *type_name, R &amp;) const</td></tr>
<tr class="memdesc:ab541b268a2aad607ceec3a3da7be8ba0 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a pointer to a user defined data for experimental purposes.  <br /></td></tr>
<tr class="separator:ab541b268a2aad607ceec3a3da7be8ba0 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c428d4e7a1134f806fcf7b15dc35e7 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a64c428d4e7a1134f806fcf7b15dc35e7">IsTensor</a> () const</td></tr>
<tr class="memdesc:a64c428d4e7a1134f806fcf7b15dc35e7 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <a class="el" href="struct_ort_1_1_value.html" title="Wrapper around OrtValue.">Value</a> is a tensor, false for other types like map/sequence/etc.  <br /></td></tr>
<tr class="separator:a64c428d4e7a1134f806fcf7b15dc35e7 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2656357fbdb63bcaa3b319191e4e37a inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#aa2656357fbdb63bcaa3b319191e4e37a">HasValue</a> () const</td></tr>
<tr class="separator:aa2656357fbdb63bcaa3b319191e4e37a inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0589e1f752d7b18a850699be24c8c84 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#ab0589e1f752d7b18a850699be24c8c84">GetCount</a> () const</td></tr>
<tr class="memdesc:ab0589e1f752d7b18a850699be24c8c84 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; Return true if OrtValue contains data and returns false if the OrtValue is a None  <br /></td></tr>
<tr class="separator:ab0589e1f752d7b18a850699be24c8c84 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc98d55540fa407b10b06ee4e6a2849 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ort_1_1_value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#aafc98d55540fa407b10b06ee4e6a2849">GetValue</a> (int index, <a class="el" href="struct_ort_allocator.html">OrtAllocator</a> *allocator) const</td></tr>
<tr class="separator:aafc98d55540fa407b10b06ee4e6a2849 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2700d2f2a5d9a7922c81419cc9fed664 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a2700d2f2a5d9a7922c81419cc9fed664">GetStringTensorDataLength</a> () const</td></tr>
<tr class="memdesc:a2700d2f2a5d9a7922c81419cc9fed664 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API returns a full length of string data contained within either a tensor or a sparse Tensor. For sparse tensor it returns a full length of stored non-empty strings (values). The API is useful for allocating necessary memory and calling <a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a00830aa9d8da4892472df573b3bb1656" title="The API copies all of the UTF-8 encoded string data contained within a tensor or a sparse tensor into...">GetStringTensorContent()</a>.  <br /></td></tr>
<tr class="separator:a2700d2f2a5d9a7922c81419cc9fed664 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00830aa9d8da4892472df573b3bb1656 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a00830aa9d8da4892472df573b3bb1656">GetStringTensorContent</a> (void *buffer, size_t buffer_length, size_t *offsets, size_t offsets_count) const</td></tr>
<tr class="memdesc:a00830aa9d8da4892472df573b3bb1656 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API copies all of the UTF-8 encoded string data contained within a tensor or a sparse tensor into a supplied buffer. Use <a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a2700d2f2a5d9a7922c81419cc9fed664" title="This API returns a full length of string data contained within either a tensor or a sparse Tensor....">GetStringTensorDataLength()</a> to find out the length of the buffer to allocate. The user must also allocate offsets buffer with the number of entries equal to that of the contained strings.  <br /></td></tr>
<tr class="separator:a00830aa9d8da4892472df573b3bb1656 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed947feb6d46847d3d6cc0289b377fe6 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:aed947feb6d46847d3d6cc0289b377fe6 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memTemplItemLeft" align="right" valign="top">const R *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#aed947feb6d46847d3d6cc0289b377fe6">GetTensorData</a> () const</td></tr>
<tr class="memdesc:aed947feb6d46847d3d6cc0289b377fe6 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const typed pointer to the tensor contained data. No type checking is performed, the caller must ensure the type matches the tensor type.  <br /></td></tr>
<tr class="separator:aed947feb6d46847d3d6cc0289b377fe6 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183c3ebf0e4d24698a782674fb9cced0 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a183c3ebf0e4d24698a782674fb9cced0">GetTensorRawData</a> () const</td></tr>
<tr class="memdesc:a183c3ebf0e4d24698a782674fb9cced0 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a non-typed pointer to a tensor contained data.  <br /></td></tr>
<tr class="separator:a183c3ebf0e4d24698a782674fb9cced0 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff868faaa0f476137844f1fe6053e42 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ort_1_1_type_info.html">TypeInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a5ff868faaa0f476137844f1fe6053e42">GetTypeInfo</a> () const</td></tr>
<tr class="memdesc:a5ff868faaa0f476137844f1fe6053e42 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API returns type information for data contained in a tensor. For sparse tensors it returns type information for contained non-zero values. It returns dense shape for sparse tensors.  <br /></td></tr>
<tr class="separator:a5ff868faaa0f476137844f1fe6053e42 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f945911eac6ee23534ce527488a6d5e inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ort_1_1_tensor_type_and_shape_info.html">TensorTypeAndShapeInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a9f945911eac6ee23534ce527488a6d5e">GetTensorTypeAndShapeInfo</a> () const</td></tr>
<tr class="memdesc:a9f945911eac6ee23534ce527488a6d5e inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API returns type information for data contained in a tensor. For sparse tensors it returns type information for contained non-zero values. It returns dense shape for sparse tensors.  <br /></td></tr>
<tr class="separator:a9f945911eac6ee23534ce527488a6d5e inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7342c33f055407202f6b0e4ed209ead0 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ort.html#a07ba56d21401a0ccb036dc08a21a904f">ConstMemoryInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a7342c33f055407202f6b0e4ed209ead0">GetTensorMemoryInfo</a> () const</td></tr>
<tr class="memdesc:a7342c33f055407202f6b0e4ed209ead0 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API returns information about the memory allocation used to hold data.  <br /></td></tr>
<tr class="separator:a7342c33f055407202f6b0e4ed209ead0 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11173caf6ac2fdc03fb1c3981fec9b3d inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a11173caf6ac2fdc03fb1c3981fec9b3d">GetStringTensorElement</a> (size_t buffer_length, size_t element_index, void *buffer) const</td></tr>
<tr class="memdesc:a11173caf6ac2fdc03fb1c3981fec9b3d inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API copies UTF-8 encoded bytes for the requested string element contained within a tensor or a sparse tensor into a provided buffer. Use <a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a21460daeba8be912b5d21ef9aa6dd717" title="The API returns a byte length of UTF-8 encoded string element contained in either a tensor or a spare...">GetStringTensorElementLength()</a> to obtain the length of the buffer to allocate.  <br /></td></tr>
<tr class="separator:a11173caf6ac2fdc03fb1c3981fec9b3d inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21460daeba8be912b5d21ef9aa6dd717 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a21460daeba8be912b5d21ef9aa6dd717">GetStringTensorElementLength</a> (size_t element_index) const</td></tr>
<tr class="memdesc:a21460daeba8be912b5d21ef9aa6dd717 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API returns a byte length of UTF-8 encoded string element contained in either a tensor or a spare tensor values.  <br /></td></tr>
<tr class="separator:a21460daeba8be912b5d21ef9aa6dd717 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc36132cb6a308a8beaa5ebaaf1aea58 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___global.html#gaba2697542109e4ab6b24a8fbb847812d">OrtSparseFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#afc36132cb6a308a8beaa5ebaaf1aea58">GetSparseFormat</a> () const</td></tr>
<tr class="memdesc:afc36132cb6a308a8beaa5ebaaf1aea58 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API returns the sparse data format this OrtValue holds in a sparse tensor. If the sparse tensor was not fully constructed, i.e. Use*() or Fill*() API were not used the value returned is ORT_SPARSE_UNDEFINED.  <br /></td></tr>
<tr class="separator:afc36132cb6a308a8beaa5ebaaf1aea58 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab986f32751dc04d125b310fb91b05ab7 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ort_1_1_tensor_type_and_shape_info.html">TensorTypeAndShapeInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#ab986f32751dc04d125b310fb91b05ab7">GetSparseTensorValuesTypeAndShapeInfo</a> () const</td></tr>
<tr class="memdesc:ab986f32751dc04d125b310fb91b05ab7 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API returns type and shape information for stored non-zero values of the sparse tensor. Use <a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a98ed067e5d11dde40386232f0ed33211" title="The API returns a pointer to an internal buffer of the sparse tensor containing non-zero values....">GetSparseTensorValues()</a> to obtain values buffer pointer.  <br /></td></tr>
<tr class="separator:ab986f32751dc04d125b310fb91b05ab7 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f83505e75304b45d70c8e41e65a070 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ort_1_1_tensor_type_and_shape_info.html">TensorTypeAndShapeInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a14f83505e75304b45d70c8e41e65a070">GetSparseTensorIndicesTypeShapeInfo</a> (<a class="el" href="group___global.html#ga497c04502f658b896b265233fc890787">OrtSparseIndicesFormat</a> format) const</td></tr>
<tr class="memdesc:a14f83505e75304b45d70c8e41e65a070 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API returns type and shape information for the specified indices. Each supported indices have their own enum values even if a give format has more than one kind of indices. Use <a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a6100cd63b21154bf72baf191c52631cd" title="The API retrieves a pointer to the internal indices buffer. The API merely performs a convenience dat...">GetSparseTensorIndicesData()</a> to obtain pointer to indices buffer.  <br /></td></tr>
<tr class="separator:a14f83505e75304b45d70c8e41e65a070 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6100cd63b21154bf72baf191c52631cd inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a6100cd63b21154bf72baf191c52631cd inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memTemplItemLeft" align="right" valign="top">const R *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a6100cd63b21154bf72baf191c52631cd">GetSparseTensorIndicesData</a> (<a class="el" href="group___global.html#ga497c04502f658b896b265233fc890787">OrtSparseIndicesFormat</a> indices_format, size_t &amp;num_indices) const</td></tr>
<tr class="memdesc:a6100cd63b21154bf72baf191c52631cd inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API retrieves a pointer to the internal indices buffer. The API merely performs a convenience data type casting on the return type pointer. Make sure you are requesting the right type, use <a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a14f83505e75304b45d70c8e41e65a070" title="The API returns type and shape information for the specified indices. Each supported indices have the...">GetSparseTensorIndicesTypeShapeInfo()</a>;.  <br /></td></tr>
<tr class="separator:a6100cd63b21154bf72baf191c52631cd inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446256778924195baf3e340711a6ef44 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a446256778924195baf3e340711a6ef44">IsSparseTensor</a> () const</td></tr>
<tr class="memdesc:a446256778924195baf3e340711a6ef44 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the OrtValue contains a sparse tensor.  <br /></td></tr>
<tr class="separator:a446256778924195baf3e340711a6ef44 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ed067e5d11dde40386232f0ed33211 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a98ed067e5d11dde40386232f0ed33211 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memTemplItemLeft" align="right" valign="top">const R *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a98ed067e5d11dde40386232f0ed33211">GetSparseTensorValues</a> () const</td></tr>
<tr class="memdesc:a98ed067e5d11dde40386232f0ed33211 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API returns a pointer to an internal buffer of the sparse tensor containing non-zero values. The API merely does casting. Make sure you are requesting the right data type by calling <a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#ab986f32751dc04d125b310fb91b05ab7" title="The API returns type and shape information for stored non-zero values of the sparse tensor....">GetSparseTensorValuesTypeAndShapeInfo()</a> first.  <br /></td></tr>
<tr class="separator:a98ed067e5d11dde40386232f0ed33211 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_struct_ort_1_1detail_1_1_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_struct_ort_1_1detail_1_1_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="struct_ort_1_1detail_1_1_base.html">Ort::detail::Base&lt; T &gt;</a></td></tr>
<tr class="memitem:a4e1e8b70ad961418f80b41a4c37429f6 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_base.html#a4e1e8b70ad961418f80b41a4c37429f6">Base</a> ()=default</td></tr>
<tr class="separator:a4e1e8b70ad961418f80b41a4c37429f6 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8072f7970ea1835bddf9aa5038d972b4 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_base.html#a8072f7970ea1835bddf9aa5038d972b4">Base</a> (<a class="el" href="struct_ort_1_1detail_1_1_base.html#adac6328b9d9b37cddd94f6b21bebee74">contained_type</a> *p) noexcept</td></tr>
<tr class="separator:a8072f7970ea1835bddf9aa5038d972b4 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd548d8facd5ee95fb8f4f4383fb8bf6 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_base.html#acd548d8facd5ee95fb8f4f4383fb8bf6">~Base</a> ()</td></tr>
<tr class="separator:acd548d8facd5ee95fb8f4f4383fb8bf6 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f40aacd24f0ba79db2dae8165930498 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_base.html#a7f40aacd24f0ba79db2dae8165930498">Base</a> (const <a class="el" href="struct_ort_1_1detail_1_1_base.html">Base</a> &amp;)=delete</td></tr>
<tr class="separator:a7f40aacd24f0ba79db2dae8165930498 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f197409cc84018ee2fe04844f188959 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ort_1_1detail_1_1_base.html">Base</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_base.html#a8f197409cc84018ee2fe04844f188959">operator=</a> (const <a class="el" href="struct_ort_1_1detail_1_1_base.html">Base</a> &amp;)=delete</td></tr>
<tr class="separator:a8f197409cc84018ee2fe04844f188959 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ed2c8723bd744b585c65e214156665 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_base.html#a36ed2c8723bd744b585c65e214156665">Base</a> (<a class="el" href="struct_ort_1_1detail_1_1_base.html">Base</a> &amp;&amp;v) noexcept</td></tr>
<tr class="separator:a36ed2c8723bd744b585c65e214156665 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10471dad43b6c80043d0714ae6544c9 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ort_1_1detail_1_1_base.html">Base</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_base.html#ab10471dad43b6c80043d0714ae6544c9">operator=</a> (<a class="el" href="struct_ort_1_1detail_1_1_base.html">Base</a> &amp;&amp;v) noexcept</td></tr>
<tr class="separator:ab10471dad43b6c80043d0714ae6544c9 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04e81c6255e5907c49afc2324b80211 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_base.html#aa04e81c6255e5907c49afc2324b80211">operator contained_type *</a> () const noexcept</td></tr>
<tr class="separator:aa04e81c6255e5907c49afc2324b80211 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e438d539c77870789686c70b031802 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ort_1_1detail_1_1_base.html#adac6328b9d9b37cddd94f6b21bebee74">contained_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_base.html#a77e438d539c77870789686c70b031802">release</a> ()</td></tr>
<tr class="memdesc:a77e438d539c77870789686c70b031802 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relinquishes ownership of the contained C object pointer The underlying object is not destroyed.  <br /></td></tr>
<tr class="separator:a77e438d539c77870789686c70b031802 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a3898146b5fc35b838bd48db807dd6c8e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3898146b5fc35b838bd48db807dd6c8e"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="struct_ort_1_1_value.html">Value</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#a3898146b5fc35b838bd48db807dd6c8e">CreateTensor</a> (const <a class="el" href="group___global.html#ga088f45e429651ac29b4a9efb4d88571a">OrtMemoryInfo</a> *info, T *p_data, size_t p_data_element_count, const int64_t *shape, size_t shape_len)</td></tr>
<tr class="memdesc:a3898146b5fc35b838bd48db807dd6c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a tensor with a user supplied buffer. Wraps <a class="el" href="struct_ort_api.html#a2aad3ccd68c66d0b38bdb966467d9324" title="Create a tensor backed by a user supplied buffer.">OrtApi::CreateTensorWithDataAsOrtValue</a>.  <br /></td></tr>
<tr class="separator:a3898146b5fc35b838bd48db807dd6c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19ff01babfb77660ed022c4057046ef"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_ort_1_1_value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#ab19ff01babfb77660ed022c4057046ef">CreateTensor</a> (const <a class="el" href="group___global.html#ga088f45e429651ac29b4a9efb4d88571a">OrtMemoryInfo</a> *info, void *p_data, size_t p_data_byte_count, const int64_t *shape, size_t shape_len, <a class="el" href="group___global.html#gaec63cdda46c29b8183997f38930ce38e">ONNXTensorElementDataType</a> type)</td></tr>
<tr class="memdesc:ab19ff01babfb77660ed022c4057046ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a tensor with a user supplied buffer. Wraps <a class="el" href="struct_ort_api.html#a2aad3ccd68c66d0b38bdb966467d9324" title="Create a tensor backed by a user supplied buffer.">OrtApi::CreateTensorWithDataAsOrtValue</a>.  <br /></td></tr>
<tr class="separator:ab19ff01babfb77660ed022c4057046ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acacfe668acf9b55ffcd9d375c7f32053"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acacfe668acf9b55ffcd9d375c7f32053"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="struct_ort_1_1_value.html">Value</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#acacfe668acf9b55ffcd9d375c7f32053">CreateTensor</a> (<a class="el" href="struct_ort_allocator.html">OrtAllocator</a> *allocator, const int64_t *shape, size_t shape_len)</td></tr>
<tr class="memdesc:acacfe668acf9b55ffcd9d375c7f32053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a tensor using a supplied <a class="el" href="struct_ort_allocator.html" title="Memory allocation interface.">OrtAllocator</a>. Wraps <a class="el" href="struct_ort_api.html#afa229d9d92820cc59298ed38d3f4f73f" title="Create a tensor.">OrtApi::CreateTensorAsOrtValue</a>.  <br /></td></tr>
<tr class="separator:acacfe668acf9b55ffcd9d375c7f32053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d35080239ae47cdbc9e505666dc32ec"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_ort_1_1_value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#a5d35080239ae47cdbc9e505666dc32ec">CreateTensor</a> (<a class="el" href="struct_ort_allocator.html">OrtAllocator</a> *allocator, const int64_t *shape, size_t shape_len, <a class="el" href="group___global.html#gaec63cdda46c29b8183997f38930ce38e">ONNXTensorElementDataType</a> type)</td></tr>
<tr class="memdesc:a5d35080239ae47cdbc9e505666dc32ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a tensor using a supplied <a class="el" href="struct_ort_allocator.html" title="Memory allocation interface.">OrtAllocator</a>. Wraps <a class="el" href="struct_ort_api.html#afa229d9d92820cc59298ed38d3f4f73f" title="Create a tensor.">OrtApi::CreateTensorAsOrtValue</a>.  <br /></td></tr>
<tr class="separator:a5d35080239ae47cdbc9e505666dc32ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028498f12d19f373b7479abe8a4a8b75"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_ort_1_1_value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#a028498f12d19f373b7479abe8a4a8b75">CreateMap</a> (<a class="el" href="struct_ort_1_1_value.html">Value</a> &amp;keys, <a class="el" href="struct_ort_1_1_value.html">Value</a> &amp;values)</td></tr>
<tr class="memdesc:a028498f12d19f373b7479abe8a4a8b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps <a class="el" href="struct_ort_api.html#ac0a58d7d43a98ebe44a2d2f7f8406415" title="Create a map or sequence OrtValue.">OrtApi::CreateValue</a>.  <br /></td></tr>
<tr class="separator:a028498f12d19f373b7479abe8a4a8b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ca9c86f4996e9490e7e9de960f7afc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_ort_1_1_value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#ad4ca9c86f4996e9490e7e9de960f7afc">CreateSequence</a> (std::vector&lt; <a class="el" href="struct_ort_1_1_value.html">Value</a> &gt; &amp;values)</td></tr>
<tr class="memdesc:ad4ca9c86f4996e9490e7e9de960f7afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps <a class="el" href="struct_ort_api.html#ac0a58d7d43a98ebe44a2d2f7f8406415" title="Create a map or sequence OrtValue.">OrtApi::CreateValue</a>.  <br /></td></tr>
<tr class="separator:ad4ca9c86f4996e9490e7e9de960f7afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8bad055b8cdaa1fb57f9aba9e6773e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aba8bad055b8cdaa1fb57f9aba9e6773e"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="struct_ort_1_1_value.html">Value</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#aba8bad055b8cdaa1fb57f9aba9e6773e">CreateOpaque</a> (const char *domain, const char *type_name, const T &amp;)</td></tr>
<tr class="memdesc:aba8bad055b8cdaa1fb57f9aba9e6773e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps <a class="el" href="struct_ort_api.html#ae12e59921f2c3480bb4bc0fcf7ddd6ec" title="Create an opaque (custom user defined type) OrtValue.">OrtApi::CreateOpaqueValue</a>.  <br /></td></tr>
<tr class="separator:aba8bad055b8cdaa1fb57f9aba9e6773e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07bd3c4da603a8fc23ea6e1f86482f6b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a07bd3c4da603a8fc23ea6e1f86482f6b"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="struct_ort_1_1_value.html">Value</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#a07bd3c4da603a8fc23ea6e1f86482f6b">CreateSparseTensor</a> (const <a class="el" href="group___global.html#ga088f45e429651ac29b4a9efb4d88571a">OrtMemoryInfo</a> *info, T *p_data, const <a class="el" href="struct_ort_1_1_value.html#aa887af73b5a841819423295063c10836">Shape</a> &amp;dense_shape, const <a class="el" href="struct_ort_1_1_value.html#aa887af73b5a841819423295063c10836">Shape</a> &amp;values_shape)</td></tr>
<tr class="memdesc:a07bd3c4da603a8fc23ea6e1f86482f6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a simple forwarding method to the other overload that helps deducing data type enum value from the type of the buffer.  <br /></td></tr>
<tr class="separator:a07bd3c4da603a8fc23ea6e1f86482f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a059315bd22476066e30a2d6034bfb9d3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_ort_1_1_value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#a059315bd22476066e30a2d6034bfb9d3">CreateSparseTensor</a> (const <a class="el" href="group___global.html#ga088f45e429651ac29b4a9efb4d88571a">OrtMemoryInfo</a> *info, void *p_data, const <a class="el" href="struct_ort_1_1_value.html#aa887af73b5a841819423295063c10836">Shape</a> &amp;dense_shape, const <a class="el" href="struct_ort_1_1_value.html#aa887af73b5a841819423295063c10836">Shape</a> &amp;values_shape, <a class="el" href="group___global.html#gaec63cdda46c29b8183997f38930ce38e">ONNXTensorElementDataType</a> type)</td></tr>
<tr class="memdesc:a059315bd22476066e30a2d6034bfb9d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an OrtValue instance containing SparseTensor. This constructs a sparse tensor that makes use of user allocated buffers. It does not make copies of the user provided data and does not modify it. The lifespan of user provided buffers should eclipse the life span of the resulting OrtValue. This call constructs an instance that only contain a pointer to non-zero values. To fully populate the sparse tensor call Use&lt;Format&gt;Indices() API below to supply a sparse format specific indices. This API is not suitable for string data. Use <a class="el" href="struct_ort_1_1_value.html#a07bd3c4da603a8fc23ea6e1f86482f6b" title="This is a simple forwarding method to the other overload that helps deducing data type enum value fro...">CreateSparseTensor()</a> with allocator specified so strings can be properly copied into the allocated buffer.  <br /></td></tr>
<tr class="separator:a059315bd22476066e30a2d6034bfb9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a560452c9940a9756089e42d767932e46"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a560452c9940a9756089e42d767932e46"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="struct_ort_1_1_value.html">Value</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#a560452c9940a9756089e42d767932e46">CreateSparseTensor</a> (<a class="el" href="struct_ort_allocator.html">OrtAllocator</a> *allocator, const <a class="el" href="struct_ort_1_1_value.html#aa887af73b5a841819423295063c10836">Shape</a> &amp;dense_shape)</td></tr>
<tr class="memdesc:a560452c9940a9756089e42d767932e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a simple forwarding method to the below CreateSparseTensor. This helps to specify data type enum in terms of C++ data type. Use CreateSparseTensor&lt;T&gt;  <br /></td></tr>
<tr class="separator:a560452c9940a9756089e42d767932e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ae05c786194af9ba2e541a91233b2f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_ort_1_1_value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#a15ae05c786194af9ba2e541a91233b2f">CreateSparseTensor</a> (<a class="el" href="struct_ort_allocator.html">OrtAllocator</a> *allocator, const <a class="el" href="struct_ort_1_1_value.html#aa887af73b5a841819423295063c10836">Shape</a> &amp;dense_shape, <a class="el" href="group___global.html#gaec63cdda46c29b8183997f38930ce38e">ONNXTensorElementDataType</a> type)</td></tr>
<tr class="memdesc:a15ae05c786194af9ba2e541a91233b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of OrtValue containing sparse tensor. The created instance has no data. The data must be supplied by on of the FillSparseTensor&lt;Format&gt;() methods that take both non-zero values and indices. The data will be copied into a buffer that would be allocated using the supplied allocator. Use this API to create OrtValues that contain sparse tensors with all supported data types including strings.  <br /></td></tr>
<tr class="separator:a15ae05c786194af9ba2e541a91233b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_struct_ort_1_1detail_1_1_base"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_struct_ort_1_1detail_1_1_base')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="struct_ort_1_1detail_1_1_base.html">Ort::detail::Base&lt; T &gt;</a></td></tr>
<tr class="memitem:ac618b65a5500fb65b7419b465cfd3d65 inherit pro_attribs_struct_ort_1_1detail_1_1_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ort_1_1detail_1_1_base.html#adac6328b9d9b37cddd94f6b21bebee74">contained_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_base.html#ac618b65a5500fb65b7419b465cfd3d65">p_</a> {}</td></tr>
<tr class="separator:ac618b65a5500fb65b7419b465cfd3d65 inherit pro_attribs_struct_ort_1_1detail_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Wrapper around <a class="el" href="group___global.html#gaab167acf3fe9dabc0195b993fbe7ee7d">OrtValue</a>. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="acaa37dd471180adc7e0feba8bee065c9" name="acaa37dd471180adc7e0feba8bee065c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaa37dd471180adc7e0feba8bee065c9">&#9670;&#160;</a></span>Base</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="struct_ort_1_1_value.html#acaa37dd471180adc7e0feba8bee065c9">Ort::Value::Base</a> =  <a class="el" href="struct_ort_1_1detail_1_1_value_impl.html">detail::ValueImpl</a>&lt;<a class="el" href="group___global.html#gaab167acf3fe9dabc0195b993fbe7ee7d">OrtValue</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a488c55bbedb38c3f505a4fe6accc36bf" name="a488c55bbedb38c3f505a4fe6accc36bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a488c55bbedb38c3f505a4fe6accc36bf">&#9670;&#160;</a></span>OrtSparseValuesParam</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="struct_ort_1_1_value.html#a488c55bbedb38c3f505a4fe6accc36bf">Ort::Value::OrtSparseValuesParam</a> =  <a class="el" href="struct_ort_1_1detail_1_1_ort_sparse_values_param.html">detail::OrtSparseValuesParam</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa887af73b5a841819423295063c10836" name="aa887af73b5a841819423295063c10836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa887af73b5a841819423295063c10836">&#9670;&#160;</a></span>Shape</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="struct_ort_1_1_value.html#aa887af73b5a841819423295063c10836">Ort::Value::Shape</a> =  <a class="el" href="struct_ort_1_1detail_1_1_shape.html">detail::Shape</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a233d9a9878a69295ad504ea2b22b4d1f" name="a233d9a9878a69295ad504ea2b22b4d1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a233d9a9878a69295ad504ea2b22b4d1f">&#9670;&#160;</a></span>Value() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ort::Value::Value </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an empty <a class="el" href="struct_ort_1_1_value.html" title="Wrapper around OrtValue.">Value</a> object, must be assigned a valid one to be used. </p>

</div>
</div>
<a id="a4e744a54c1fe6c477cccbe33b580fe3b" name="a4e744a54c1fe6c477cccbe33b580fe3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e744a54c1fe6c477cccbe33b580fe3b">&#9670;&#160;</a></span>Value() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ort::Value::Value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___global.html#gaab167acf3fe9dabc0195b993fbe7ee7d">OrtValue</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used for interop with the C API. </p>

</div>
</div>
<a id="a1b7884f57758a06ca3b1203fcff98a08" name="a1b7884f57758a06ca3b1203fcff98a08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7884f57758a06ca3b1203fcff98a08">&#9670;&#160;</a></span>Value() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ort::Value::Value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ort_1_1_value.html">Value</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a028498f12d19f373b7479abe8a4a8b75" name="a028498f12d19f373b7479abe8a4a8b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028498f12d19f373b7479abe8a4a8b75">&#9670;&#160;</a></span>CreateMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_ort_1_1_value.html">Value</a> Ort::Value::CreateMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ort_1_1_value.html">Value</a> &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ort_1_1_value.html">Value</a> &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps <a class="el" href="struct_ort_api.html#ac0a58d7d43a98ebe44a2d2f7f8406415" title="Create a map or sequence OrtValue.">OrtApi::CreateValue</a>. </p>

</div>
</div>
<a id="aba8bad055b8cdaa1fb57f9aba9e6773e" name="aba8bad055b8cdaa1fb57f9aba9e6773e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba8bad055b8cdaa1fb57f9aba9e6773e">&#9670;&#160;</a></span>CreateOpaque()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_ort_1_1_value.html">Value</a> Ort::Value::CreateOpaque </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps <a class="el" href="struct_ort_api.html#ae12e59921f2c3480bb4bc0fcf7ddd6ec" title="Create an opaque (custom user defined type) OrtValue.">OrtApi::CreateOpaqueValue</a>. </p>

</div>
</div>
<a id="ad4ca9c86f4996e9490e7e9de960f7afc" name="ad4ca9c86f4996e9490e7e9de960f7afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ca9c86f4996e9490e7e9de960f7afc">&#9670;&#160;</a></span>CreateSequence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_ort_1_1_value.html">Value</a> Ort::Value::CreateSequence </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_ort_1_1_value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps <a class="el" href="struct_ort_api.html#ac0a58d7d43a98ebe44a2d2f7f8406415" title="Create a map or sequence OrtValue.">OrtApi::CreateValue</a>. </p>

</div>
</div>
<a id="a07bd3c4da603a8fc23ea6e1f86482f6b" name="a07bd3c4da603a8fc23ea6e1f86482f6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07bd3c4da603a8fc23ea6e1f86482f6b">&#9670;&#160;</a></span>CreateSparseTensor() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_ort_1_1_value.html">Value</a> Ort::Value::CreateSparseTensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___global.html#ga088f45e429651ac29b4a9efb4d88571a">OrtMemoryInfo</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ort_1_1_value.html#aa887af73b5a841819423295063c10836">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>dense_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ort_1_1_value.html#aa887af73b5a841819423295063c10836">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>values_shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a simple forwarding method to the other overload that helps deducing data type enum value from the type of the buffer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>numeric datatype. This API is not suitable for strings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>Memory description where the user buffers reside (CPU vs GPU etc)</td></tr>
    <tr><td class="paramname">p_data</td><td>pointer to the user supplied buffer, use nullptr for fully sparse tensors</td></tr>
    <tr><td class="paramname">dense_shape</td><td>a would be dense shape of the tensor</td></tr>
    <tr><td class="paramname">values_shape</td><td>non zero values shape. Use a single 0 shape for fully sparse tensors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a059315bd22476066e30a2d6034bfb9d3" name="a059315bd22476066e30a2d6034bfb9d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a059315bd22476066e30a2d6034bfb9d3">&#9670;&#160;</a></span>CreateSparseTensor() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_ort_1_1_value.html">Value</a> Ort::Value::CreateSparseTensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___global.html#ga088f45e429651ac29b4a9efb4d88571a">OrtMemoryInfo</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ort_1_1_value.html#aa887af73b5a841819423295063c10836">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>dense_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ort_1_1_value.html#aa887af73b5a841819423295063c10836">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>values_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___global.html#gaec63cdda46c29b8183997f38930ce38e">ONNXTensorElementDataType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an OrtValue instance containing SparseTensor. This constructs a sparse tensor that makes use of user allocated buffers. It does not make copies of the user provided data and does not modify it. The lifespan of user provided buffers should eclipse the life span of the resulting OrtValue. This call constructs an instance that only contain a pointer to non-zero values. To fully populate the sparse tensor call Use&lt;Format&gt;Indices() API below to supply a sparse format specific indices. This API is not suitable for string data. Use <a class="el" href="struct_ort_1_1_value.html#a07bd3c4da603a8fc23ea6e1f86482f6b" title="This is a simple forwarding method to the other overload that helps deducing data type enum value fro...">CreateSparseTensor()</a> with allocator specified so strings can be properly copied into the allocated buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>Memory description where the user buffers reside (CPU vs GPU etc)</td></tr>
    <tr><td class="paramname">p_data</td><td>pointer to the user supplied buffer, use nullptr for fully sparse tensors</td></tr>
    <tr><td class="paramname">dense_shape</td><td>a would be dense shape of the tensor</td></tr>
    <tr><td class="paramname">values_shape</td><td>non zero values shape. Use a single 0 shape for fully sparse tensors.</td></tr>
    <tr><td class="paramname">type</td><td>data type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_ort_1_1_value.html" title="Wrapper around OrtValue.">Ort::Value</a> instance containing SparseTensor</dd></dl>

</div>
</div>
<a id="a560452c9940a9756089e42d767932e46" name="a560452c9940a9756089e42d767932e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a560452c9940a9756089e42d767932e46">&#9670;&#160;</a></span>CreateSparseTensor() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_ort_1_1_value.html">Value</a> Ort::Value::CreateSparseTensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ort_allocator.html">OrtAllocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ort_1_1_value.html#aa887af73b5a841819423295063c10836">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>dense_shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a simple forwarding method to the below CreateSparseTensor. This helps to specify data type enum in terms of C++ data type. Use CreateSparseTensor&lt;T&gt; </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>numeric data type only. String data enum must be specified explicitly.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>allocator to use</td></tr>
    <tr><td class="paramname">dense_shape</td><td>a would be dense shape of the tensor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_ort_1_1_value.html" title="Wrapper around OrtValue.">Ort::Value</a></dd></dl>

</div>
</div>
<a id="a15ae05c786194af9ba2e541a91233b2f" name="a15ae05c786194af9ba2e541a91233b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15ae05c786194af9ba2e541a91233b2f">&#9670;&#160;</a></span>CreateSparseTensor() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_ort_1_1_value.html">Value</a> Ort::Value::CreateSparseTensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ort_allocator.html">OrtAllocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ort_1_1_value.html#aa887af73b5a841819423295063c10836">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>dense_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___global.html#gaec63cdda46c29b8183997f38930ce38e">ONNXTensorElementDataType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an instance of OrtValue containing sparse tensor. The created instance has no data. The data must be supplied by on of the FillSparseTensor&lt;Format&gt;() methods that take both non-zero values and indices. The data will be copied into a buffer that would be allocated using the supplied allocator. Use this API to create OrtValues that contain sparse tensors with all supported data types including strings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>allocator to use. The allocator lifespan must eclipse that of the resulting OrtValue</td></tr>
    <tr><td class="paramname">dense_shape</td><td>a would be dense shape of the tensor</td></tr>
    <tr><td class="paramname">type</td><td>data type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an instance of <a class="el" href="struct_ort_1_1_value.html" title="Wrapper around OrtValue.">Ort::Value</a></dd></dl>

</div>
</div>
<a id="a3898146b5fc35b838bd48db807dd6c8e" name="a3898146b5fc35b838bd48db807dd6c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3898146b5fc35b838bd48db807dd6c8e">&#9670;&#160;</a></span>CreateTensor() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_ort_1_1_value.html">Value</a> Ort::Value::CreateTensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___global.html#ga088f45e429651ac29b4a9efb4d88571a">OrtMemoryInfo</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>p_data_element_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>shape_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a tensor with a user supplied buffer. Wraps <a class="el" href="struct_ort_api.html#a2aad3ccd68c66d0b38bdb966467d9324" title="Create a tensor backed by a user supplied buffer.">OrtApi::CreateTensorWithDataAsOrtValue</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The numeric datatype. This API is not suitable for strings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>Memory description of where the p_data buffer resides (CPU vs GPU etc). </td></tr>
    <tr><td class="paramname">p_data</td><td>Pointer to the data buffer. </td></tr>
    <tr><td class="paramname">p_data_element_count</td><td>The number of elements in the data buffer. </td></tr>
    <tr><td class="paramname">shape</td><td>Pointer to the tensor shape dimensions. </td></tr>
    <tr><td class="paramname">shape_len</td><td>The number of tensor shape dimensions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab19ff01babfb77660ed022c4057046ef" name="ab19ff01babfb77660ed022c4057046ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19ff01babfb77660ed022c4057046ef">&#9670;&#160;</a></span>CreateTensor() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_ort_1_1_value.html">Value</a> Ort::Value::CreateTensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___global.html#ga088f45e429651ac29b4a9efb4d88571a">OrtMemoryInfo</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>p_data_byte_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>shape_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___global.html#gaec63cdda46c29b8183997f38930ce38e">ONNXTensorElementDataType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a tensor with a user supplied buffer. Wraps <a class="el" href="struct_ort_api.html#a2aad3ccd68c66d0b38bdb966467d9324" title="Create a tensor backed by a user supplied buffer.">OrtApi::CreateTensorWithDataAsOrtValue</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>Memory description of where the p_data buffer resides (CPU vs GPU etc). </td></tr>
    <tr><td class="paramname">p_data</td><td>Pointer to the data buffer. </td></tr>
    <tr><td class="paramname">p_data_byte_count</td><td>The number of bytes in the data buffer. </td></tr>
    <tr><td class="paramname">shape</td><td>Pointer to the tensor shape dimensions. </td></tr>
    <tr><td class="paramname">shape_len</td><td>The number of tensor shape dimensions. </td></tr>
    <tr><td class="paramname">type</td><td>The data type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acacfe668acf9b55ffcd9d375c7f32053" name="acacfe668acf9b55ffcd9d375c7f32053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acacfe668acf9b55ffcd9d375c7f32053">&#9670;&#160;</a></span>CreateTensor() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_ort_1_1_value.html">Value</a> Ort::Value::CreateTensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ort_allocator.html">OrtAllocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>shape_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a tensor using a supplied <a class="el" href="struct_ort_allocator.html" title="Memory allocation interface.">OrtAllocator</a>. Wraps <a class="el" href="struct_ort_api.html#afa229d9d92820cc59298ed38d3f4f73f" title="Create a tensor.">OrtApi::CreateTensorAsOrtValue</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The numeric datatype. This API is not suitable for strings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The allocator to use. </td></tr>
    <tr><td class="paramname">shape</td><td>Pointer to the tensor shape dimensions. </td></tr>
    <tr><td class="paramname">shape_len</td><td>The number of tensor shape dimensions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d35080239ae47cdbc9e505666dc32ec" name="a5d35080239ae47cdbc9e505666dc32ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d35080239ae47cdbc9e505666dc32ec">&#9670;&#160;</a></span>CreateTensor() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_ort_1_1_value.html">Value</a> Ort::Value::CreateTensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ort_allocator.html">OrtAllocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>shape_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___global.html#gaec63cdda46c29b8183997f38930ce38e">ONNXTensorElementDataType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a tensor using a supplied <a class="el" href="struct_ort_allocator.html" title="Memory allocation interface.">OrtAllocator</a>. Wraps <a class="el" href="struct_ort_api.html#afa229d9d92820cc59298ed38d3f4f73f" title="Create a tensor.">OrtApi::CreateTensorAsOrtValue</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The allocator to use. </td></tr>
    <tr><td class="paramname">shape</td><td>Pointer to the tensor shape dimensions. </td></tr>
    <tr><td class="paramname">shape_len</td><td>The number of tensor shape dimensions. </td></tr>
    <tr><td class="paramname">type</td><td>The data type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7df58aec9512b5744e9869b0360ee77" name="ae7df58aec9512b5744e9869b0360ee77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7df58aec9512b5744e9869b0360ee77">&#9670;&#160;</a></span>GetConst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ort.html#afe583bdd408314ab9216f27997fe3cfe">ConstValue</a> Ort::Value::GetConst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5def834adf6750b31b7fdead89b67a07" name="a5def834adf6750b31b7fdead89b67a07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5def834adf6750b31b7fdead89b67a07">&#9670;&#160;</a></span>GetUnowned()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ort.html#ae76d2b32827c348b72fbe4091ee40f92">UnownedValue</a> Ort::Value::GetUnowned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a14ce9c0a1b41a61eb0f94bc9070539eb" name="a14ce9c0a1b41a61eb0f94bc9070539eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ce9c0a1b41a61eb0f94bc9070539eb">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ort_1_1_value.html">Value</a> &amp; Ort::Value::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ort_1_1_value.html">Value</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ort.html">Ort</a></li><li class="navelem"><a class="el" href="struct_ort_1_1_value.html">Value</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>

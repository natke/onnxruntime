<!-- HTML header for doxygen -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OnnxRuntime: Ort::detail::ValueImpl&lt; T &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-156955408-1"></script><script type="text/javascript">"use strict"; window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-156955408-1'); </script> <script type="text/javascript" src="/assets/js/vendor/lunr.min.js"></script> <script type="text/javascript" src="/assets/js/just-the-docs.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ONNX_Runtime_logo - Docs.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OnnxRuntime
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('struct_ort_1_1detail_1_1_value_impl.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="struct_ort_1_1detail_1_1_value_impl-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Ort::detail::ValueImpl&lt; T &gt; Struct Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="onnxruntime__cxx__api_8h_source.html">onnxruntime_cxx_api.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Ort::detail::ValueImpl&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="struct_ort_1_1detail_1_1_value_impl.png" usemap="#Ort::detail::ValueImpl_3C_20T_20_3E_map" alt=""/>
  <map id="Ort::detail::ValueImpl_3C_20T_20_3E_map" name="Ort::detail::ValueImpl_3C_20T_20_3E_map">
<area href="struct_ort_1_1detail_1_1_const_value_impl.html" alt="Ort::detail::ConstValueImpl&lt; T &gt;" shape="rect" coords="0,56,190,80"/>
<area href="struct_ort_1_1detail_1_1_base.html" title="Used internally by the C++ API. C++ wrapper types inherit from this. This is a zero cost abstraction ..." alt="Ort::detail::Base&lt; T &gt;" shape="rect" coords="0,0,190,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa56bd5e28c57ca24311ce48792326d6e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_value_impl.html#aa56bd5e28c57ca24311ce48792326d6e">B</a> = <a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html">ConstValueImpl</a>&lt; T &gt;</td></tr>
<tr class="separator:aa56bd5e28c57ca24311ce48792326d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80f19abb74be8f5a489ae95eaa13905"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_value_impl.html#ab80f19abb74be8f5a489ae95eaa13905">B</a> = <a class="el" href="struct_ort_1_1detail_1_1_base.html">Base</a>&lt; T &gt;</td></tr>
<tr class="separator:ab80f19abb74be8f5a489ae95eaa13905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_struct_ort_1_1detail_1_1_const_value_impl"><td colspan="2" onclick="javascript:toggleInherit('pub_types_struct_ort_1_1detail_1_1_const_value_impl')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html">Ort::detail::ConstValueImpl&lt; T &gt;</a></td></tr>
<tr class="memitem:ab80f19abb74be8f5a489ae95eaa13905 inherit pub_types_struct_ort_1_1detail_1_1_const_value_impl"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#ab80f19abb74be8f5a489ae95eaa13905">B</a> = <a class="el" href="struct_ort_1_1detail_1_1_base.html">Base</a>&lt; T &gt;</td></tr>
<tr class="separator:ab80f19abb74be8f5a489ae95eaa13905 inherit pub_types_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_struct_ort_1_1detail_1_1_base"><td colspan="2" onclick="javascript:toggleInherit('pub_types_struct_ort_1_1detail_1_1_base')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="struct_ort_1_1detail_1_1_base.html">Ort::detail::Base&lt; T &gt;</a></td></tr>
<tr class="memitem:adac6328b9d9b37cddd94f6b21bebee74 inherit pub_types_struct_ort_1_1detail_1_1_base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_base.html#adac6328b9d9b37cddd94f6b21bebee74">contained_type</a> = T</td></tr>
<tr class="separator:adac6328b9d9b37cddd94f6b21bebee74 inherit pub_types_struct_ort_1_1detail_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a28317ae875d9c8b35f0cbed64f776c5a"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a28317ae875d9c8b35f0cbed64f776c5a"><td class="memTemplItemLeft" align="right" valign="top">R *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_value_impl.html#a28317ae875d9c8b35f0cbed64f776c5a">GetTensorMutableData</a> ()</td></tr>
<tr class="memdesc:a28317ae875d9c8b35f0cbed64f776c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a non-const typed pointer to an OrtValue/Tensor contained buffer No type checking is performed, the caller must ensure the type matches the tensor type.  <br /></td></tr>
<tr class="separator:a28317ae875d9c8b35f0cbed64f776c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b55de64b5457b5fd0538ec8225a0507"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_value_impl.html#a8b55de64b5457b5fd0538ec8225a0507">GetTensorMutableRawData</a> ()</td></tr>
<tr class="memdesc:a8b55de64b5457b5fd0538ec8225a0507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a non-typed non-const pointer to a tensor contained data.  <br /></td></tr>
<tr class="separator:a8b55de64b5457b5fd0538ec8225a0507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657fe9ca6bd6e2dc09c0beb95ee3e1eb"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a657fe9ca6bd6e2dc09c0beb95ee3e1eb"><td class="memTemplItemLeft" align="right" valign="top">R &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_value_impl.html#a657fe9ca6bd6e2dc09c0beb95ee3e1eb">At</a> (const std::vector&lt; int64_t &gt; &amp;location)</td></tr>
<tr class="separator:a657fe9ca6bd6e2dc09c0beb95ee3e1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98717a93e02f4b91ebabaf3c4ab891c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_value_impl.html#ac98717a93e02f4b91ebabaf3c4ab891c">FillStringTensor</a> (const char *const *s, size_t s_len)</td></tr>
<tr class="memdesc:ac98717a93e02f4b91ebabaf3c4ab891c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all strings at once in a string tensor.  <br /></td></tr>
<tr class="separator:ac98717a93e02f4b91ebabaf3c4ab891c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a59534f82ccf9ff55b8a692270e4503"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_value_impl.html#a0a59534f82ccf9ff55b8a692270e4503">FillStringTensorElement</a> (const char *s, size_t index)</td></tr>
<tr class="memdesc:a0a59534f82ccf9ff55b8a692270e4503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a single string in a string tensor.  <br /></td></tr>
<tr class="separator:a0a59534f82ccf9ff55b8a692270e4503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b80e2a725f45cdeceb06bcba643e978"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_value_impl.html#a8b80e2a725f45cdeceb06bcba643e978">UseCooIndices</a> (int64_t *indices_data, size_t indices_num)</td></tr>
<tr class="memdesc:a8b80e2a725f45cdeceb06bcba643e978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supplies COO format specific indices and marks the contained sparse tensor as being a COO format tensor. Values are supplied with a CreateSparseTensor() API. The supplied indices are not copied and the user allocated buffers lifespan must eclipse that of the OrtValue. The location of the indices is assumed to be the same as specified by OrtMemoryInfo argument at the creation time.  <br /></td></tr>
<tr class="separator:a8b80e2a725f45cdeceb06bcba643e978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc53699ae881046ccf26527fb0e0d7d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_value_impl.html#adc53699ae881046ccf26527fb0e0d7d2">UseCsrIndices</a> (int64_t *inner_data, size_t inner_num, int64_t *outer_data, size_t outer_num)</td></tr>
<tr class="memdesc:adc53699ae881046ccf26527fb0e0d7d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supplies CSR format specific indices and marks the contained sparse tensor as being a CSR format tensor. Values are supplied with a CreateSparseTensor() API. The supplied indices are not copied and the user allocated buffers lifespan must eclipse that of the OrtValue. The location of the indices is assumed to be the same as specified by OrtMemoryInfo argument at the creation time.  <br /></td></tr>
<tr class="separator:adc53699ae881046ccf26527fb0e0d7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ba9e6d44e6a1141c04d1fefaa3b6c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_value_impl.html#a68ba9e6d44e6a1141c04d1fefaa3b6c6">UseBlockSparseIndices</a> (const <a class="el" href="struct_ort_1_1detail_1_1_shape.html">Shape</a> &amp;indices_shape, int32_t *indices_data)</td></tr>
<tr class="memdesc:a68ba9e6d44e6a1141c04d1fefaa3b6c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supplies BlockSparse format specific indices and marks the contained sparse tensor as being a BlockSparse format tensor. Values are supplied with a CreateSparseTensor() API. The supplied indices are not copied and the user allocated buffers lifespan must eclipse that of the OrtValue. The location of the indices is assumed to be the same as specified by OrtMemoryInfo argument at the creation time.  <br /></td></tr>
<tr class="separator:a68ba9e6d44e6a1141c04d1fefaa3b6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30c08c17ce26d0c89e8c7dea62f9a75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_value_impl.html#ab30c08c17ce26d0c89e8c7dea62f9a75">FillSparseTensorCoo</a> (const <a class="el" href="group___global.html#ga088f45e429651ac29b4a9efb4d88571a">OrtMemoryInfo</a> *data_mem_info, const <a class="el" href="struct_ort_1_1detail_1_1_ort_sparse_values_param.html">OrtSparseValuesParam</a> &amp;values_param, const int64_t *indices_data, size_t indices_num)</td></tr>
<tr class="memdesc:ab30c08c17ce26d0c89e8c7dea62f9a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API will allocate memory using the allocator instance supplied to the CreateSparseTensor() API and copy the values and COO indices into it. If data_mem_info specifies that the data is located at difference device than the allocator, a X-device copy will be performed if possible.  <br /></td></tr>
<tr class="separator:ab30c08c17ce26d0c89e8c7dea62f9a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67cc830bdf35e40717b06ca70b22ead"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_value_impl.html#af67cc830bdf35e40717b06ca70b22ead">FillSparseTensorCsr</a> (const <a class="el" href="group___global.html#ga088f45e429651ac29b4a9efb4d88571a">OrtMemoryInfo</a> *data_mem_info, const <a class="el" href="struct_ort_1_1detail_1_1_ort_sparse_values_param.html">OrtSparseValuesParam</a> &amp;values, const int64_t *inner_indices_data, size_t inner_indices_num, const int64_t *outer_indices_data, size_t outer_indices_num)</td></tr>
<tr class="memdesc:af67cc830bdf35e40717b06ca70b22ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API will allocate memory using the allocator instance supplied to the CreateSparseTensor() API and copy the values and CSR indices into it. If data_mem_info specifies that the data is located at difference device than the allocator, a X-device copy will be performed if possible.  <br /></td></tr>
<tr class="separator:af67cc830bdf35e40717b06ca70b22ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a57d606a608abda7df7b9b23a301a3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_value_impl.html#a7a57d606a608abda7df7b9b23a301a3e">FillSparseTensorBlockSparse</a> (const <a class="el" href="group___global.html#ga088f45e429651ac29b4a9efb4d88571a">OrtMemoryInfo</a> *data_mem_info, const <a class="el" href="struct_ort_1_1detail_1_1_ort_sparse_values_param.html">OrtSparseValuesParam</a> &amp;values, const <a class="el" href="struct_ort_1_1detail_1_1_shape.html">Shape</a> &amp;indices_shape, const int32_t *indices_data)</td></tr>
<tr class="memdesc:a7a57d606a608abda7df7b9b23a301a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API will allocate memory using the allocator instance supplied to the CreateSparseTensor() API and copy the values and BlockSparse indices into it. If data_mem_info specifies that the data is located at difference device than the allocator, a X-device copy will be performed if possible.  <br /></td></tr>
<tr class="separator:a7a57d606a608abda7df7b9b23a301a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_struct_ort_1_1detail_1_1_const_value_impl')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html">Ort::detail::ConstValueImpl&lt; T &gt;</a></td></tr>
<tr class="memitem:ab541b268a2aad607ceec3a3da7be8ba0 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:ab541b268a2aad607ceec3a3da7be8ba0 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#ab541b268a2aad607ceec3a3da7be8ba0">GetOpaqueData</a> (const char *domain, const char *type_name, R &amp;) const</td></tr>
<tr class="memdesc:ab541b268a2aad607ceec3a3da7be8ba0 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a pointer to a user defined data for experimental purposes.  <br /></td></tr>
<tr class="separator:ab541b268a2aad607ceec3a3da7be8ba0 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c428d4e7a1134f806fcf7b15dc35e7 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a64c428d4e7a1134f806fcf7b15dc35e7">IsTensor</a> () const</td></tr>
<tr class="memdesc:a64c428d4e7a1134f806fcf7b15dc35e7 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <a class="el" href="struct_ort_1_1_value.html" title="Wrapper around OrtValue.">Value</a> is a tensor, false for other types like map/sequence/etc.  <br /></td></tr>
<tr class="separator:a64c428d4e7a1134f806fcf7b15dc35e7 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2656357fbdb63bcaa3b319191e4e37a inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#aa2656357fbdb63bcaa3b319191e4e37a">HasValue</a> () const</td></tr>
<tr class="separator:aa2656357fbdb63bcaa3b319191e4e37a inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0589e1f752d7b18a850699be24c8c84 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#ab0589e1f752d7b18a850699be24c8c84">GetCount</a> () const</td></tr>
<tr class="memdesc:ab0589e1f752d7b18a850699be24c8c84 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; Return true if OrtValue contains data and returns false if the OrtValue is a None  <br /></td></tr>
<tr class="separator:ab0589e1f752d7b18a850699be24c8c84 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc98d55540fa407b10b06ee4e6a2849 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ort_1_1_value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#aafc98d55540fa407b10b06ee4e6a2849">GetValue</a> (int index, <a class="el" href="struct_ort_allocator.html">OrtAllocator</a> *allocator) const</td></tr>
<tr class="separator:aafc98d55540fa407b10b06ee4e6a2849 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2700d2f2a5d9a7922c81419cc9fed664 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a2700d2f2a5d9a7922c81419cc9fed664">GetStringTensorDataLength</a> () const</td></tr>
<tr class="memdesc:a2700d2f2a5d9a7922c81419cc9fed664 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API returns a full length of string data contained within either a tensor or a sparse Tensor. For sparse tensor it returns a full length of stored non-empty strings (values). The API is useful for allocating necessary memory and calling <a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a00830aa9d8da4892472df573b3bb1656" title="The API copies all of the UTF-8 encoded string data contained within a tensor or a sparse tensor into...">GetStringTensorContent()</a>.  <br /></td></tr>
<tr class="separator:a2700d2f2a5d9a7922c81419cc9fed664 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00830aa9d8da4892472df573b3bb1656 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a00830aa9d8da4892472df573b3bb1656">GetStringTensorContent</a> (void *buffer, size_t buffer_length, size_t *offsets, size_t offsets_count) const</td></tr>
<tr class="memdesc:a00830aa9d8da4892472df573b3bb1656 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API copies all of the UTF-8 encoded string data contained within a tensor or a sparse tensor into a supplied buffer. Use <a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a2700d2f2a5d9a7922c81419cc9fed664" title="This API returns a full length of string data contained within either a tensor or a sparse Tensor....">GetStringTensorDataLength()</a> to find out the length of the buffer to allocate. The user must also allocate offsets buffer with the number of entries equal to that of the contained strings.  <br /></td></tr>
<tr class="separator:a00830aa9d8da4892472df573b3bb1656 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed947feb6d46847d3d6cc0289b377fe6 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:aed947feb6d46847d3d6cc0289b377fe6 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memTemplItemLeft" align="right" valign="top">const R *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#aed947feb6d46847d3d6cc0289b377fe6">GetTensorData</a> () const</td></tr>
<tr class="memdesc:aed947feb6d46847d3d6cc0289b377fe6 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const typed pointer to the tensor contained data. No type checking is performed, the caller must ensure the type matches the tensor type.  <br /></td></tr>
<tr class="separator:aed947feb6d46847d3d6cc0289b377fe6 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183c3ebf0e4d24698a782674fb9cced0 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a183c3ebf0e4d24698a782674fb9cced0">GetTensorRawData</a> () const</td></tr>
<tr class="memdesc:a183c3ebf0e4d24698a782674fb9cced0 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a non-typed pointer to a tensor contained data.  <br /></td></tr>
<tr class="separator:a183c3ebf0e4d24698a782674fb9cced0 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff868faaa0f476137844f1fe6053e42 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ort_1_1_type_info.html">TypeInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a5ff868faaa0f476137844f1fe6053e42">GetTypeInfo</a> () const</td></tr>
<tr class="memdesc:a5ff868faaa0f476137844f1fe6053e42 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API returns type information for data contained in a tensor. For sparse tensors it returns type information for contained non-zero values. It returns dense shape for sparse tensors.  <br /></td></tr>
<tr class="separator:a5ff868faaa0f476137844f1fe6053e42 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f945911eac6ee23534ce527488a6d5e inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ort_1_1_tensor_type_and_shape_info.html">TensorTypeAndShapeInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a9f945911eac6ee23534ce527488a6d5e">GetTensorTypeAndShapeInfo</a> () const</td></tr>
<tr class="memdesc:a9f945911eac6ee23534ce527488a6d5e inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API returns type information for data contained in a tensor. For sparse tensors it returns type information for contained non-zero values. It returns dense shape for sparse tensors.  <br /></td></tr>
<tr class="separator:a9f945911eac6ee23534ce527488a6d5e inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7342c33f055407202f6b0e4ed209ead0 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ort.html#a07ba56d21401a0ccb036dc08a21a904f">ConstMemoryInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a7342c33f055407202f6b0e4ed209ead0">GetTensorMemoryInfo</a> () const</td></tr>
<tr class="memdesc:a7342c33f055407202f6b0e4ed209ead0 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API returns information about the memory allocation used to hold data.  <br /></td></tr>
<tr class="separator:a7342c33f055407202f6b0e4ed209ead0 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11173caf6ac2fdc03fb1c3981fec9b3d inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a11173caf6ac2fdc03fb1c3981fec9b3d">GetStringTensorElement</a> (size_t buffer_length, size_t element_index, void *buffer) const</td></tr>
<tr class="memdesc:a11173caf6ac2fdc03fb1c3981fec9b3d inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API copies UTF-8 encoded bytes for the requested string element contained within a tensor or a sparse tensor into a provided buffer. Use <a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a21460daeba8be912b5d21ef9aa6dd717" title="The API returns a byte length of UTF-8 encoded string element contained in either a tensor or a spare...">GetStringTensorElementLength()</a> to obtain the length of the buffer to allocate.  <br /></td></tr>
<tr class="separator:a11173caf6ac2fdc03fb1c3981fec9b3d inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21460daeba8be912b5d21ef9aa6dd717 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a21460daeba8be912b5d21ef9aa6dd717">GetStringTensorElementLength</a> (size_t element_index) const</td></tr>
<tr class="memdesc:a21460daeba8be912b5d21ef9aa6dd717 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API returns a byte length of UTF-8 encoded string element contained in either a tensor or a spare tensor values.  <br /></td></tr>
<tr class="separator:a21460daeba8be912b5d21ef9aa6dd717 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc36132cb6a308a8beaa5ebaaf1aea58 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___global.html#gaba2697542109e4ab6b24a8fbb847812d">OrtSparseFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#afc36132cb6a308a8beaa5ebaaf1aea58">GetSparseFormat</a> () const</td></tr>
<tr class="memdesc:afc36132cb6a308a8beaa5ebaaf1aea58 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API returns the sparse data format this OrtValue holds in a sparse tensor. If the sparse tensor was not fully constructed, i.e. Use*() or Fill*() API were not used the value returned is ORT_SPARSE_UNDEFINED.  <br /></td></tr>
<tr class="separator:afc36132cb6a308a8beaa5ebaaf1aea58 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab986f32751dc04d125b310fb91b05ab7 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ort_1_1_tensor_type_and_shape_info.html">TensorTypeAndShapeInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#ab986f32751dc04d125b310fb91b05ab7">GetSparseTensorValuesTypeAndShapeInfo</a> () const</td></tr>
<tr class="memdesc:ab986f32751dc04d125b310fb91b05ab7 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API returns type and shape information for stored non-zero values of the sparse tensor. Use <a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a98ed067e5d11dde40386232f0ed33211" title="The API returns a pointer to an internal buffer of the sparse tensor containing non-zero values....">GetSparseTensorValues()</a> to obtain values buffer pointer.  <br /></td></tr>
<tr class="separator:ab986f32751dc04d125b310fb91b05ab7 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f83505e75304b45d70c8e41e65a070 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ort_1_1_tensor_type_and_shape_info.html">TensorTypeAndShapeInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a14f83505e75304b45d70c8e41e65a070">GetSparseTensorIndicesTypeShapeInfo</a> (<a class="el" href="group___global.html#ga497c04502f658b896b265233fc890787">OrtSparseIndicesFormat</a> format) const</td></tr>
<tr class="memdesc:a14f83505e75304b45d70c8e41e65a070 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API returns type and shape information for the specified indices. Each supported indices have their own enum values even if a give format has more than one kind of indices. Use <a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a6100cd63b21154bf72baf191c52631cd" title="The API retrieves a pointer to the internal indices buffer. The API merely performs a convenience dat...">GetSparseTensorIndicesData()</a> to obtain pointer to indices buffer.  <br /></td></tr>
<tr class="separator:a14f83505e75304b45d70c8e41e65a070 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6100cd63b21154bf72baf191c52631cd inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a6100cd63b21154bf72baf191c52631cd inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memTemplItemLeft" align="right" valign="top">const R *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a6100cd63b21154bf72baf191c52631cd">GetSparseTensorIndicesData</a> (<a class="el" href="group___global.html#ga497c04502f658b896b265233fc890787">OrtSparseIndicesFormat</a> indices_format, size_t &amp;num_indices) const</td></tr>
<tr class="memdesc:a6100cd63b21154bf72baf191c52631cd inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API retrieves a pointer to the internal indices buffer. The API merely performs a convenience data type casting on the return type pointer. Make sure you are requesting the right type, use <a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a14f83505e75304b45d70c8e41e65a070" title="The API returns type and shape information for the specified indices. Each supported indices have the...">GetSparseTensorIndicesTypeShapeInfo()</a>;.  <br /></td></tr>
<tr class="separator:a6100cd63b21154bf72baf191c52631cd inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446256778924195baf3e340711a6ef44 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a446256778924195baf3e340711a6ef44">IsSparseTensor</a> () const</td></tr>
<tr class="memdesc:a446256778924195baf3e340711a6ef44 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the OrtValue contains a sparse tensor.  <br /></td></tr>
<tr class="separator:a446256778924195baf3e340711a6ef44 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ed067e5d11dde40386232f0ed33211 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a98ed067e5d11dde40386232f0ed33211 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memTemplItemLeft" align="right" valign="top">const R *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#a98ed067e5d11dde40386232f0ed33211">GetSparseTensorValues</a> () const</td></tr>
<tr class="memdesc:a98ed067e5d11dde40386232f0ed33211 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API returns a pointer to an internal buffer of the sparse tensor containing non-zero values. The API merely does casting. Make sure you are requesting the right data type by calling <a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html#ab986f32751dc04d125b310fb91b05ab7" title="The API returns type and shape information for stored non-zero values of the sparse tensor....">GetSparseTensorValuesTypeAndShapeInfo()</a> first.  <br /></td></tr>
<tr class="separator:a98ed067e5d11dde40386232f0ed33211 inherit pub_methods_struct_ort_1_1detail_1_1_const_value_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_struct_ort_1_1detail_1_1_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_struct_ort_1_1detail_1_1_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="struct_ort_1_1detail_1_1_base.html">Ort::detail::Base&lt; T &gt;</a></td></tr>
<tr class="memitem:a4e1e8b70ad961418f80b41a4c37429f6 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_base.html#a4e1e8b70ad961418f80b41a4c37429f6">Base</a> ()=default</td></tr>
<tr class="separator:a4e1e8b70ad961418f80b41a4c37429f6 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8072f7970ea1835bddf9aa5038d972b4 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_base.html#a8072f7970ea1835bddf9aa5038d972b4">Base</a> (<a class="el" href="struct_ort_1_1detail_1_1_base.html#adac6328b9d9b37cddd94f6b21bebee74">contained_type</a> *p) noexcept</td></tr>
<tr class="separator:a8072f7970ea1835bddf9aa5038d972b4 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd548d8facd5ee95fb8f4f4383fb8bf6 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_base.html#acd548d8facd5ee95fb8f4f4383fb8bf6">~Base</a> ()</td></tr>
<tr class="separator:acd548d8facd5ee95fb8f4f4383fb8bf6 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f40aacd24f0ba79db2dae8165930498 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_base.html#a7f40aacd24f0ba79db2dae8165930498">Base</a> (const <a class="el" href="struct_ort_1_1detail_1_1_base.html">Base</a> &amp;)=delete</td></tr>
<tr class="separator:a7f40aacd24f0ba79db2dae8165930498 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f197409cc84018ee2fe04844f188959 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ort_1_1detail_1_1_base.html">Base</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_base.html#a8f197409cc84018ee2fe04844f188959">operator=</a> (const <a class="el" href="struct_ort_1_1detail_1_1_base.html">Base</a> &amp;)=delete</td></tr>
<tr class="separator:a8f197409cc84018ee2fe04844f188959 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ed2c8723bd744b585c65e214156665 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_base.html#a36ed2c8723bd744b585c65e214156665">Base</a> (<a class="el" href="struct_ort_1_1detail_1_1_base.html">Base</a> &amp;&amp;v) noexcept</td></tr>
<tr class="separator:a36ed2c8723bd744b585c65e214156665 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10471dad43b6c80043d0714ae6544c9 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ort_1_1detail_1_1_base.html">Base</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_base.html#ab10471dad43b6c80043d0714ae6544c9">operator=</a> (<a class="el" href="struct_ort_1_1detail_1_1_base.html">Base</a> &amp;&amp;v) noexcept</td></tr>
<tr class="separator:ab10471dad43b6c80043d0714ae6544c9 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04e81c6255e5907c49afc2324b80211 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_base.html#aa04e81c6255e5907c49afc2324b80211">operator contained_type *</a> () const noexcept</td></tr>
<tr class="separator:aa04e81c6255e5907c49afc2324b80211 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e438d539c77870789686c70b031802 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ort_1_1detail_1_1_base.html#adac6328b9d9b37cddd94f6b21bebee74">contained_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_base.html#a77e438d539c77870789686c70b031802">release</a> ()</td></tr>
<tr class="memdesc:a77e438d539c77870789686c70b031802 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relinquishes ownership of the contained C object pointer The underlying object is not destroyed.  <br /></td></tr>
<tr class="separator:a77e438d539c77870789686c70b031802 inherit pub_methods_struct_ort_1_1detail_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_struct_ort_1_1detail_1_1_base"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_struct_ort_1_1detail_1_1_base')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="struct_ort_1_1detail_1_1_base.html">Ort::detail::Base&lt; T &gt;</a></td></tr>
<tr class="memitem:ac618b65a5500fb65b7419b465cfd3d65 inherit pro_attribs_struct_ort_1_1detail_1_1_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ort_1_1detail_1_1_base.html#adac6328b9d9b37cddd94f6b21bebee74">contained_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1detail_1_1_base.html#ac618b65a5500fb65b7419b465cfd3d65">p_</a> {}</td></tr>
<tr class="separator:ac618b65a5500fb65b7419b465cfd3d65 inherit pro_attribs_struct_ort_1_1detail_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aa56bd5e28c57ca24311ce48792326d6e" name="aa56bd5e28c57ca24311ce48792326d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa56bd5e28c57ca24311ce48792326d6e">&#9670;&#160;</a></span>B <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="struct_ort_1_1detail_1_1_value_impl.html">Ort::detail::ValueImpl</a>&lt; T &gt;::B =  <a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html">ConstValueImpl</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab80f19abb74be8f5a489ae95eaa13905" name="ab80f19abb74be8f5a489ae95eaa13905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab80f19abb74be8f5a489ae95eaa13905">&#9670;&#160;</a></span>B <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="struct_ort_1_1detail_1_1_const_value_impl.html">Ort::detail::ConstValueImpl</a>&lt; T &gt;::B =  <a class="el" href="struct_ort_1_1detail_1_1_base.html">Base</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a657fe9ca6bd6e2dc09c0beb95ee3e1eb" name="a657fe9ca6bd6e2dc09c0beb95ee3e1eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a657fe9ca6bd6e2dc09c0beb95ee3e1eb">&#9670;&#160;</a></span>At()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">R &amp; <a class="el" href="struct_ort_1_1detail_1_1_value_impl.html">Ort::detail::ValueImpl</a>&lt; T &gt;::At </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>location</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>by the vector of dims.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>[in] expressed by a vecotr of dimensions offsets</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a7a57d606a608abda7df7b9b23a301a3e" name="a7a57d606a608abda7df7b9b23a301a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a57d606a608abda7df7b9b23a301a3e">&#9670;&#160;</a></span>FillSparseTensorBlockSparse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_ort_1_1detail_1_1_value_impl.html">Ort::detail::ValueImpl</a>&lt; T &gt;::FillSparseTensorBlockSparse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___global.html#ga088f45e429651ac29b4a9efb4d88571a">OrtMemoryInfo</a> *&#160;</td>
          <td class="paramname"><em>data_mem_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ort_1_1detail_1_1_ort_sparse_values_param.html">OrtSparseValuesParam</a> &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ort_1_1detail_1_1_shape.html">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>indices_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t *&#160;</td>
          <td class="paramname"><em>indices_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The API will allocate memory using the allocator instance supplied to the CreateSparseTensor() API and copy the values and BlockSparse indices into it. If data_mem_info specifies that the data is located at difference device than the allocator, a X-device copy will be performed if possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_mem_info</td><td>specified buffer memory description</td></tr>
    <tr><td class="paramname">values</td><td>values buffer information</td></tr>
    <tr><td class="paramname">indices_shape</td><td>indices shape. use {0} for fully sparse tensors</td></tr>
    <tr><td class="paramname">indices_data</td><td>pointer to indices data or nullptr for fully sparse tensors</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab30c08c17ce26d0c89e8c7dea62f9a75" name="ab30c08c17ce26d0c89e8c7dea62f9a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab30c08c17ce26d0c89e8c7dea62f9a75">&#9670;&#160;</a></span>FillSparseTensorCoo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_ort_1_1detail_1_1_value_impl.html">Ort::detail::ValueImpl</a>&lt; T &gt;::FillSparseTensorCoo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___global.html#ga088f45e429651ac29b4a9efb4d88571a">OrtMemoryInfo</a> *&#160;</td>
          <td class="paramname"><em>data_mem_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ort_1_1detail_1_1_ort_sparse_values_param.html">OrtSparseValuesParam</a> &amp;&#160;</td>
          <td class="paramname"><em>values_param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>indices_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>indices_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The API will allocate memory using the allocator instance supplied to the CreateSparseTensor() API and copy the values and COO indices into it. If data_mem_info specifies that the data is located at difference device than the allocator, a X-device copy will be performed if possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_mem_info</td><td>specified buffer memory description</td></tr>
    <tr><td class="paramname">values_param</td><td>values buffer information.</td></tr>
    <tr><td class="paramname">indices_data</td><td>coo indices buffer or nullptr for fully sparse data</td></tr>
    <tr><td class="paramname">indices_num</td><td>number of COO indices or 0 for fully sparse data</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af67cc830bdf35e40717b06ca70b22ead" name="af67cc830bdf35e40717b06ca70b22ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af67cc830bdf35e40717b06ca70b22ead">&#9670;&#160;</a></span>FillSparseTensorCsr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_ort_1_1detail_1_1_value_impl.html">Ort::detail::ValueImpl</a>&lt; T &gt;::FillSparseTensorCsr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___global.html#ga088f45e429651ac29b4a9efb4d88571a">OrtMemoryInfo</a> *&#160;</td>
          <td class="paramname"><em>data_mem_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ort_1_1detail_1_1_ort_sparse_values_param.html">OrtSparseValuesParam</a> &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>inner_indices_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inner_indices_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>outer_indices_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>outer_indices_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The API will allocate memory using the allocator instance supplied to the CreateSparseTensor() API and copy the values and CSR indices into it. If data_mem_info specifies that the data is located at difference device than the allocator, a X-device copy will be performed if possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_mem_info</td><td>specified buffer memory description</td></tr>
    <tr><td class="paramname">values</td><td>values buffer information</td></tr>
    <tr><td class="paramname">inner_indices_data</td><td>csr inner indices pointer or nullptr for fully sparse tensors</td></tr>
    <tr><td class="paramname">inner_indices_num</td><td>number of csr inner indices or 0 for fully sparse tensors</td></tr>
    <tr><td class="paramname">outer_indices_data</td><td>pointer to csr indices data or nullptr for fully sparse tensors</td></tr>
    <tr><td class="paramname">outer_indices_num</td><td>number of csr outer indices or 0</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac98717a93e02f4b91ebabaf3c4ab891c" name="ac98717a93e02f4b91ebabaf3c4ab891c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac98717a93e02f4b91ebabaf3c4ab891c">&#9670;&#160;</a></span>FillStringTensor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_ort_1_1detail_1_1_value_impl.html">Ort::detail::ValueImpl</a>&lt; T &gt;::FillStringTensor </td>
          <td>(</td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>s_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set all strings at once in a string tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>[in] An array of strings. Each string in this array must be null terminated.</td></tr>
    <tr><td class="paramname">s_len</td><td>[in] Count of strings in s (Must match the size of <code>value's</code> tensor shape)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a59534f82ccf9ff55b8a692270e4503" name="a0a59534f82ccf9ff55b8a692270e4503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a59534f82ccf9ff55b8a692270e4503">&#9670;&#160;</a></span>FillStringTensorElement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_ort_1_1detail_1_1_value_impl.html">Ort::detail::ValueImpl</a>&lt; T &gt;::FillStringTensorElement </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a single string in a string tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>[in] A null terminated UTF-8 encoded string</td></tr>
    <tr><td class="paramname">index</td><td>[in] Index of the string in the tensor to set</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28317ae875d9c8b35f0cbed64f776c5a" name="a28317ae875d9c8b35f0cbed64f776c5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28317ae875d9c8b35f0cbed64f776c5a">&#9670;&#160;</a></span>GetTensorMutableData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">R * <a class="el" href="struct_ort_1_1detail_1_1_value_impl.html">Ort::detail::ValueImpl</a>&lt; T &gt;::GetTensorMutableData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a non-const typed pointer to an OrtValue/Tensor contained buffer No type checking is performed, the caller must ensure the type matches the tensor type. </p>
<dl class="section return"><dt>Returns</dt><dd>non-const pointer to data, no copies made</dd></dl>

</div>
</div>
<a id="a8b55de64b5457b5fd0538ec8225a0507" name="a8b55de64b5457b5fd0538ec8225a0507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b55de64b5457b5fd0538ec8225a0507">&#9670;&#160;</a></span>GetTensorMutableRawData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void * <a class="el" href="struct_ort_1_1detail_1_1_value_impl.html">Ort::detail::ValueImpl</a>&lt; T &gt;::GetTensorMutableRawData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a non-typed non-const pointer to a tensor contained data. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to data, no copies made</dd></dl>

</div>
</div>
<a id="a68ba9e6d44e6a1141c04d1fefaa3b6c6" name="a68ba9e6d44e6a1141c04d1fefaa3b6c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68ba9e6d44e6a1141c04d1fefaa3b6c6">&#9670;&#160;</a></span>UseBlockSparseIndices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_ort_1_1detail_1_1_value_impl.html">Ort::detail::ValueImpl</a>&lt; T &gt;::UseBlockSparseIndices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_ort_1_1detail_1_1_shape.html">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>indices_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>indices_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supplies BlockSparse format specific indices and marks the contained sparse tensor as being a BlockSparse format tensor. Values are supplied with a CreateSparseTensor() API. The supplied indices are not copied and the user allocated buffers lifespan must eclipse that of the OrtValue. The location of the indices is assumed to be the same as specified by OrtMemoryInfo argument at the creation time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices_shape</td><td>indices shape or a {0} for fully sparse</td></tr>
    <tr><td class="paramname">indices_data</td><td>user allocated buffer with indices or nullptr for fully spare tensors</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b80e2a725f45cdeceb06bcba643e978" name="a8b80e2a725f45cdeceb06bcba643e978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b80e2a725f45cdeceb06bcba643e978">&#9670;&#160;</a></span>UseCooIndices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_ort_1_1detail_1_1_value_impl.html">Ort::detail::ValueImpl</a>&lt; T &gt;::UseCooIndices </td>
          <td>(</td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>indices_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>indices_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supplies COO format specific indices and marks the contained sparse tensor as being a COO format tensor. Values are supplied with a CreateSparseTensor() API. The supplied indices are not copied and the user allocated buffers lifespan must eclipse that of the OrtValue. The location of the indices is assumed to be the same as specified by OrtMemoryInfo argument at the creation time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices_data</td><td>pointer to the user allocated buffer with indices. Use nullptr for fully sparse tensors.</td></tr>
    <tr><td class="paramname">indices_num</td><td>number of indices entries. Use 0 for fully sparse tensors</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc53699ae881046ccf26527fb0e0d7d2" name="adc53699ae881046ccf26527fb0e0d7d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc53699ae881046ccf26527fb0e0d7d2">&#9670;&#160;</a></span>UseCsrIndices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_ort_1_1detail_1_1_value_impl.html">Ort::detail::ValueImpl</a>&lt; T &gt;::UseCsrIndices </td>
          <td>(</td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>inner_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inner_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>outer_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>outer_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supplies CSR format specific indices and marks the contained sparse tensor as being a CSR format tensor. Values are supplied with a CreateSparseTensor() API. The supplied indices are not copied and the user allocated buffers lifespan must eclipse that of the OrtValue. The location of the indices is assumed to be the same as specified by OrtMemoryInfo argument at the creation time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inner_data</td><td>pointer to the user allocated buffer with inner indices or nullptr for fully sparse tensors</td></tr>
    <tr><td class="paramname">inner_num</td><td>number of csr inner indices or 0 for fully sparse tensors</td></tr>
    <tr><td class="paramname">outer_data</td><td>pointer to the user allocated buffer with outer indices or nullptr for fully sparse tensors</td></tr>
    <tr><td class="paramname">outer_num</td><td>number of csr outer indices or 0 for fully sparse tensors</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ort.html">Ort</a></li><li class="navelem"><a class="el" href="namespace_ort_1_1detail.html">detail</a></li><li class="navelem"><a class="el" href="struct_ort_1_1detail_1_1_value_impl.html">ValueImpl</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
